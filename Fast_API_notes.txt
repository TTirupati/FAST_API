Real time project:
        https://www.youtube.com/watch?v=QQXQAZuJSdw&list=PLEt8Tae2spYnLMAf8RGCNYhovIFZHVsPP&index=1
        https://www.youtube.com/watch?v=8gx3wrGi7_U


To install FastAPI:
    pip install fastapi

To install uvicorm server like asgi server in django which is default:
    pip install uvicorm

Example:

from fastapi import FastAPI 
app = FastAPI()

@app.get("/hello")
def read_root():
    return {"Hello": "World"}

Example:
#to pass param in the get method and read the values back
@app.get("/employee/{emp_id}")
def read_employee_id(emp_id):
    return {"employee id  :":emp_id}

#to specify the type of param we an define as fallow
@app.get("/employee/{emp_id}")
def read_employee_id(emp_id: int):
    return {"employee id  :":emp_id}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}



Swagger UI: for the other or UI devloper
http://127.0.0.1:8000/docs.

https://www.youtube.com/watch?v=d_ugoWsvGLI

https://www.youtube.com/watch?v=XnYYwcOfcn8&list=PLqAmigZvYxIL9dnYeZEhMoHcoP4zop8-p
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Channel: JVP Design:
-------------------
1.Introduction

fast api is built on starlette,skeleton for the fast api and it used pydantic for the type 
checking and database vadidation etc.

1. we can create the first virtual enviroment:
2. we can create the requirement.txt file
        requirement file:
                uvicorm
                fastapi
3.install in the same enviroment: pip install -r requirement.txt 

First we need to create the main.py file, actually this is the base of the Applicaion.

main.py:

from fastapi import FastAPI

app=FastAPI()

@app.get("/")
async def root():
    return {"message":"hello world"}


Like in Django how we run the server with manage.py file same we need to run here.
uvicorm main:app
uvicorm main:app --reload
uvicorm main:app --port=5000
uvicorn main:app --host 192.168.0.132 --port 8000

Example:
main.py:
-------

from fastapi import FastAPI
app=FastAPI()

@app.get("/",description="this is our first route",deprecated=True)
async def root():
    return {"message":"hello world"}

@app.post("/")
async def post():
    return {"message ": "hello from the post route"}

@app.put("/")
async def put():
    return {"message ": "hello from the put route "}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PATH PARAMETERS:
---------------

Example: main.py:

from fastapi import FastAPI

app=FastAPI()

@app.get("/items/{item_id}")
async def root(item_id:int):
    return {"Item_id":item_id}


Example2:
from enum import Enum
from fastapi import FastAPI


app=FastAPI()

class FoodEnum(str,Enum):
    fruits='Fruits'
    vegetables='vegetables'
    dairy='dairy'

@app.get("/foods/{food_name}")
async def get(food_name:FoodEnum):
    if food_name==FoodEnum.vegetables:
        return {
                "food name ": food_name,
                "message "  :"i am healthy person"
        }

    if food_name.value=="Fruits":
        return {
                "food name ": food_name,
                "message "  :"you are still healthy but likes sweet"
        }

    return {"food name": food_name,"message ": "I like chocholate ,milk"}

enum in Python
=============
Enumerations or Enums is a set of symbolic names bound to unique values.
It can be iterated over to return its canonical members in definition order. 
It provides a way to create more readable and self-documenting code by using meaningful names
instead of arbitrary values.

Properties of Enum
------------------
Enums can be displayed as string or repr.
Enums can be checked for their types using type().
The “name” keyword is used to display the name of the enum member.

Ex:
from enum import Enum

class Season(Enum):
	SPRING = 1
	SUMMER = 2
	AUTUMN = 3
	WINTER = 4
print(Season.SPRING)
print(Season.SPRING.name)
print(Season.SPRING.value)
print(type(Season.SPRING))
print(repr(Season.SPRING))
print(list(Season))

Ex:
from enum import Enum
class Season(Enum):
	SPRING = 1
	SUMMER = 2
	AUTUMN = 3
	WINTER = 4
print("The enum member associated with value 2 is : ", Season(2).name)
print("The enum member associated with name AUTUMN is : ", Season['AUTUMN'].value)



Ex:Enumerations are iterable. They can be iterated using loops
from enum import Enum

class Season(Enum):
	SPRING = 1
	SUMMER = 2
	AUTUMN = 3
	WINTER = 4

for season in (Season):
	print(season.value,"-",season)

#Enumerations Support Hashing
import enum
class Animal(enum.Enum):
	dog = 1
	cat = 2
	lion = 3
	
di = {}
di[Animal.dog] = 'bark'
di[Animal.lion] = 'roar'

if di == {Animal.dog: 'bark', Animal.lion: 'roar'}:
	print("Enum is hashed")
	print(di)
else:
	print("Enum is not hashed")

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:3: QUERY PARAMTER:
=========================
    SO,instead of passing paramters in path where in the below example as we are defining
    as 
        @app.get("/foods/{food_name}")

    instead of the above 
    we can define as 

#we can have optional paramter with Query Paramerter but we can make it as required paramter.

from typing import Optional
from fastapi import FastAPI
app=FastAPI()


#asssume this is from databases
fake_items_db=[{"item_name":"Foo"},{"item_name":"Bar"},{"item_name":"Baz"}]

@app.get("/items")
async def list_items(skip: int=0, limit: int=10):
    #in this we are giving 0 as default value and limit should be 10 
    return fake_items_db[skip : skip + limit]

#now if we want the above parement in function as optional then we can go as 

@app.get("/items/{item_id}")
#async def get_item(item_id:str,q: Optional[str]=None):
async def get_item(item_id:str,q: str | None=None):
    if q:
        return {"item_id":item_id,"q":q}
    return {"item_id":item_id}


"""
http://127.0.0.1:8000/items?skip=0
        this will not skip any value
        [{"item_name":"Foo"},{"item_name":"Bar"},{"item_name":"Baz"}]

http://127.0.0.1:8000/items?skip=1
        this skip the first element.
        [{"item_name":"Bar"},{"item_name":"Baz"}] 

http://127.0.0.1:8000/items?skip=2
        [{"item_name":"Baz"}]

http://127.0.0.1:8000/items?skip=3
        []

http://127.0.0.1:8000/items?limit=0
        []

http://127.0.0.1:8000/items?limit=1
        [{"item_name":"Foo"}]     


"""

example:
from typing import Optional
from fastapi import FastAPI
 


app=FastAPI()


#asssume this is from databases
fake_items_db=[{"item_name":"Foo"},{"item_name":"Bar"},{"item_name":"Baz"}]

@app.get("/items")
async def list_items(skip: int=0, limit: int=10):
    #in this we are giving 0 as default value and limit should be 10 
    return fake_items_db[skip : skip + limit]

#now if we want the above parement in function as optional then we can go as 

@app.get("/items/{item_id}")
async def get_item(item_id:str,q: str | None=None,short:bool=False):
    item={"item it ":item_id}
    if q:
        item.update({"q":q})
    if not short:
        item.update(
            {
                "description":"this is my descrition of the myworld"
            }
        )
    return item

"""
 http://127.0.0.1:8000/items/hello?q=world&short=0

 o/p:
 {"item it ":"hello","q":"world","description":"this is my descrition of the myworld"}   



#Single Path Param and single Query Param.
from typing import Optional
from fastapi import FastAPI

@app.get("/items/{item_id}")
async def get_item(item_id:str,q: str | None=None,short:bool=False):
    item={"item it ":item_id}
    if q:
        item.update({"q":q})
    if not short:
        item.update(
            {
                "description":"this is my descrition of the myworld"
            }
        )
    return item

"""
 http://127.0.0.1:8000/items/hello?q=world&short=0

 o/p:
 {"item it ":"hello","q":"world","description":"this is my descrition of the myworld"}   


"""


"""
Mulitple Path and Query Param
"""

from typing import Optional
from fastapi import FastAPI

app=FastAPI()

@app.get("/user/{user_id}/items/{item_id}")
async def get_user_item(user_id:int , item_id:str , q: str|None=None, short:bool=False):
    item={'item_id':item_id,'owner id ':user_id}
    if q:
        item.update({"q":q})
    if not short:
        item.update(
            {"description ": "this is my world or programming"}
        )
    return item


"""
http://127.0.0.1:8000/user/1000/items/123?q=hello%20wolrd&short=0

{"item_id":"123","owner id ":1000,"q":"hello wolrd","description ":"this is my world or programming"}

"""

"""
All path parameter are the required Params only 
but if we make the query paramter as required parameter the we can return the paramter
in the response api.

"""

from typing import Optional
from fastapi import FastAPI

app=FastAPI()

@app.get("/user/{user_id}/items/{item_id}")
async def get_user_item(user_id:int , item_id:str , sample_required_query:str, q: str|None=None, short:bool=False):
    item={'item_id':item_id,'owner id ':user_id,"sample_required_query":sample_required_query}
    if q:
        item.update({"q":q})
    if not short:
        item.update(
            {"description ": "this is my world or programming"}
        )
    return item

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:4: REQUEST BODY:
=======================
    request body is used when we send data in the post and patch or put

"""
All path parameter are the required Params only 
but if we make the query paramter as required parameter the we can return the paramter
in the response api.

"""

from typing import Optional
from fastapi import FastAPI
from pydantic import BaseModel

app=FastAPI()


class Item(BaseModel):
    name:str
    decription:Optional[str]=None #setting this attribute as Optional it supports to 3.6 to 3.10
    price:float
    tax:float | None=None #setting this attribute as Optional it supports above 3.10


@app.post("/items")
async def create_item(item:Item):
    item_dic=item.dict() #this method comes through pydantic, anything as a basemodel, we can call the dict() method on it.

    if item.tax:
        price_with_tax=item.price+item.tax
        item_dic.update({"price with tax ": price_with_tax})
    return item_dic

#path paramter & Query Paramater
@app.put("/items/{item_id}")
async def create_item_put(item_id: int, item: Item,q:str | None=None):
    result={"item id  ": item_id,**item.dict()} #**item.dict() this will return the dic object of the base class by updating the item_id
    if q:
        result.update({"q ": q}
    )
    return result


"""
status code 422:
    in fastapi anything does not work by default it will show this status code.
"""

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:5: Query Parameters and String Validation:
==================================================

#validating the query paramater
#now i want to set the limit for the Query paramarter let say max length of the string=6

from fastapi import FastAPI,Query
from pydantic import BaseModel
@app.get("/items")
async def read_items(q: str | None=Query(None,max_length=10,min_length=3,regex="^fixedquery$")):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result
Query(None,max_length=10):
        it allows none or max length of the characters query paramter

def read_items(q: str | None=Query(None,max_length=10,min_length=3,regex="^fixedquery$")):
def read_items(q: str | None=Query("fixedQuery",max_length=10,min_length=3,regex="^fixedquery$")):

--the first paramter in the Query class is default value


Now we want include required query string.
----------------------------------------
Example:
@app.get("/items")
async def read_items(q: str):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result

or 
@app.get("/items")
async def read_items(q: str=Query(...,min_length=3,max_length=10)):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result

three dots(...) are called as elipses. which make the query paramter is required params.

Allow the muliple values from the query paramter
-------------------------------------------------
like
    http://127.0.0.1:8000/items?q=hello&q=world&q=tom

@app.get("/items")
async def read_items(q: list[str] | None=Query(None)):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result

o/p:
{"item":[{"item id ":"foo"},{"item id ":"bar"}],"q":["hello","world","tom"]}

default values as a list in Query class:
---------------------------------------
@app.get("/items")
async def read_items(q: list[str] | None=Query(["Tom","parker"])):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result


Adding the metdata for the Query params and alias to the query params
---------------------------------------------------------------------
@app.get("/items")
async def read_items(q: str | None=Query(
    None,min_length=2,
    max_length=10,
    title="this is sample title",
    description="this is sample description",
    deprecated=True,
    alias="item-query"
    )
):
    result={"item":[{"item id ":"foo"},{"item id ":"bar"}]}
    if q:
        result.update({"q":q})
    return result

http://127.0.0.1:8000/items?item-query=foobar

lets see hidding some thing:
----------------------------
@app.get("/items/hidden")
async def hidden_query_route(hidden_query:str | None=Query(None,include_in_schema=False)):
    if hidden_query:
        return {"hidden query ": hidden_query}
    return {"hidden query ": "hidden Query not Found"}

http://127.0.0.1:8000/items_hidden?hidden_query=hello%20world

 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:6: Path Parameters and Numeric Validation
==================================================
async def read_item(
    item_id: int=Path(...,title="this is path validation params"), 
    q: str | None=Query(None,alias="item-query")):
    result={"Item id ":item_id}
    if q:
        result.update({"q":q})
    return result


let say we want to make in the same example query param as required params
so we we write the example as ,

@app.get("/items_validation/{item_id}")
async def read_item(
    item_id: int=Path(...,title="this is path validation params"), 
    q: str
    ):

    result={"Item id ":item_id}
    if q:
        result.update({"q":q})
    return result

the above example throw the error as 
     q: str
    ^^^^^^
SyntaxError: non-default argument follows default argument

to resolve this issue we need to change the position of the params

-->so suppose we doesnot wants to solve the above issue by keeping no default args in the first
place instead of the we can solve like this also.

if we put the star(*), first the after this args(*), it assumes as keyword arguments.

@app.get("/items_validation/{item_id}")
async def read_item(
    *,
    item_id: int=Path(...,title="this is path validation params"), 
    q: str
    ):

    result={"Item id ":item_id}
    if q:
        result.update({"q":q})
    return result

#for the validation for fload DT
@app.get("/items_validation/{item_id}")
async def read_item(
    *,
    item_id: int=Path(...,title="this is path validation params",ge=10,le=20), 
    q: str='hello',
    size:float=Query(...,qt=0,lt=7.75)
    ):

    result={"Item id ":item_id}
    if q:
        result.update({"q":q})
    return result

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 7: Body - Multiple Parameters
=========================================
class Item(BaseModel):
    name:str
    decription:Optional[str]=None  #optional
    price:float
    tax:float | None=None           #optional

class User(BaseModel):
    username:str
    fullname:str|None=None


@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id:int=Path(...,title="this is path paramter",ge=0,le=150),
    q:str|None=None,
    item:Item |None=None,
    user:User,
    importance:int #this is query parameter
    ):

    results={"item_id":item_id}
    if q:
        results.update({"q":q})
    if item:
        results.update({"item":item})
    if user:
        results.update({"user": user})
    if importance:
        results.update({"importance":importance})

    return results

here in this example "importance" is a query parameter which is required params.

tp avoid this , now we can create one class as 
o/p:

{
  "item_id": 100,
  "item": {
    "name": "string",
    "decription": "string",
    "price": 0,
    "tax": 0
  },
  "user": {
    "username": "string",
    "fullname": "string"
  },
  "importance": {
    "importance": 0
  }
}

now this is too much for just passing one params as int value as importance class 
instead of that we can use Body() Object as we have Path() and Query()


from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel


app=FastAPI()
class Item(BaseModel):
    name:str
    decription:Optional[str]=None  #optional
    price:float
    tax:float | None=None           #optional

class User(BaseModel):
    username:str
    fullname:str|None=None
 

@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id:int=Path(...,title="this is path paramter",ge=0,le=150),
    q:str|None=None,
    item:Item |None=None,
    user:User,
    importance:int=Body(...) 
    ):

    results={"item_id":item_id}
    if q:
        results.update({"q":q})
    if item:
        results.update({"item":item})
    if user:
        results.update({"user": user})
    if importance:
        results.update({"importance":importance})

    return results
response:
{
  "item": {
    "name": "string",
    "decription": "string",
    "price": 0,
    "tax": 0
  },
  "user": {
    "username": "string",
    "fullname": "string"
  },
  "importance": 0
}

the below is the default request body:
-------------------------------------

{
  "name": "string",
  "decription": "string",
  "price": 0,
  "tax": 0
}

Now if we want every request body should be associated to some key and dictionary then we can use 
    Body(...,embed=True)

{
  "item": {
    "name": "string",
    "decription": "string",
    "price": 0,
    "tax": 0
  }
}

Example:
from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel


app=FastAPI()
class Item(BaseModel):
    name:str
    decription:Optional[str]=None  #optional
    price:float
    tax:float | None=None           #optional

class User(BaseModel):
    username:str
    fullname:str|None=None
 

@app.put("/items/{item_id}")
async def update_item(
    *,
    item_id:int=Path(...,title="this is path paramter",ge=0,le=150),
    q:str|None=None,
    item:Item=Body(...,embed=True),
 
    ):

    results={"item_id":item_id}
    if q:
        results.update({"q":q})
    if item:
        results.update({"item":item})
 

    return results


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 8: Body - Field
==============================
To specify the metadata for the BaseModel class we can use Field() object.
as we are using Path(),Body(),Query() objets for path,Request Body and Query Params repectively
the same way we can also use for BaseMode Fields

firstly we need to import the Field

from pydantic import BaseModel,Field.

class Item(BaseModel):
    name:str
    description:str=Field(...,)


from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field
app=FastAPI()

class Item(BaseModel):
    name:str
    description:str|None=Field(None,title="this is filed object ",max_length=10,min_length=3)
    price:float=Field(...,gt=0,description="the price must be greater then zero")
    tax:float|None=None

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item=Body(...,embed=True)):
    results={"item id ": item_id,"item":item}
    return results


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 9 :Body - Nested Models
=================================
--> One the way we can nest the body by using the tag:list

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[]

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results

request body
{
  "name": "hello world",
  "description": "string",
  "price": 0,
  "tax": 0,
  "tag": [100,200,"hello"]
}

so we are using pydantic we are specific to type where we are passing to list.
suppose we need to send the lst strings
Example2:
from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str]

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results

requesting body

{
  "name": "string",
  "description": "string",
  "price": 0,
  "tax": 0,
  "tag": [
    "hello","world","tom"

  ]
}

response body:
{
  "item id ": 123,
  "item": {
    "name": "string",
    "description": "string",
    "price": 0,
    "tax": 0,
    "tag": [
      "hello",
      "world",
      "tom"
    ]
  }
}

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str] #so we can pass the any type of list from here like int,float,bool

suppose if we want to take 
         tag:list=set()-->it wont behave like set again it behave like a list only

but we change like this then only it will behave like 
class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:set[str]=set()

typing should be match on the both sides.

NestTed Models:
--------------

from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Image(BaseModel):
    url:str
    name:str

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str] #so we can pass the any type of list from here like int,float,bool
    image:Image | None=None #Nested Models

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results


Response body
 
{
  "item id ": 123,
  "item": {
    "name": "string",
    "description": "string",
    "price": 0,
    "tax": 0,
    "tag": [
      "string"
    ],
    "image": {
      "url": "string",
      "name": "string"
    }
  }
}

in the above exampe we are using url as a string type:

from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Image(BaseModel):
    url:str=Field(...,regex='^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()!@:%_\+.~#?&\/\/=]*)$')
    name:str

#one of the way we can use by Field() object with regex expression, the below example is not working.
class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str] #so we can pass the any type of list from here like int,float,bool
    image:Image | None=None #Nested Models

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results

we can refer: https://ihateregex.io/?q=url for regular expression
And we can check all Field Types in Pydantic site:

second way we can accomplish this example:
from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field,HttpUrl
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Image(BaseModel):
    url:HttpUrl
    name:str

#one of the way we can use by Field() object with regex expression
class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str] #so we can pass the any type of list from here like int,float,bool
    image:Image | None=None #Nested Models

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results


suppose if we want to send list of images then :
Example:
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field,HttpUrl
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Image(BaseModel):
    url:HttpUrl
    name:str

#suppose if we want to send list of images then we can do 
class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str]  
    image:list[Image] | None=None #passing the Image class in list we can pass the list of images.

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results


Lets Nest Models within the Models Example:
------------------------------------------
from typing import Optional
from fastapi import FastAPI,Query,Path,Body
from pydantic import BaseModel,Field,HttpUrl
from typing import List #if we are using before version python 3.10 the we need to import
app=FastAPI()

class Image(BaseModel):
    url:HttpUrl
    name:str

 
class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
    tag:list=[str]  
    image:list[Image] | None=None  

class Offer(BaseModel):
    name:str
    description:str | None=None 
    price:float 
    items:list[Item]


@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results

@app.post("/offer")
async def create_offer(offer:Offer=Body(...,embed=True)):
    return offer


@app.post("/images/multiple")
async def create_multiple_images(images:list[Image]=Body(...,embed=True)):
    return images

@app.post("/sample_dict")
async def create_dict(sample_dict:dict[int,float]):
    return sample_dict

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 10: Declare Request Example Data
==========================================
    we are looking in these session how we can include information in the request body:
    there are three ways we can do this.

example1: Not Working
 
from fastapi import FastAPI 
from pydantic import BaseModel 
   
app=FastAPI()

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None

    
    class Config:
        schema_extra={
            "example":{
                "name":"Foo",
                "description":"a very price nice item",
                "price":16.25,
                "tax":1.67,

            }
        }

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results


2.Way we can achive it. not a right way:
By deafult we can get this example if we do this way:
{
  "name": "Foo",
  "description": "a very price nice item",
  "price": 16.25,
  "tax": 16.25
}

Example:
 
from fastapi import FastAPI 
from pydantic import BaseModel,Field
   
app=FastAPI()

class Item(BaseModel):
    name:str=Field(...,example="Foo")
    description:str|None=Field(None,example="a very price nice item")
    price:float=Field(...,example=16.25)
    tax:float|None=Field(None,example=16.25)

    
    class Config:
        schema_extra={
            "example":{
                "name":"Foo",
                "description":"a very price nice item",
                "price":16.25,
                "tax":1.67,

            }
        }

@app.put("/items/{item_id}")
async def update_item(item_id:int,item:Item):
    results={"item id ": item_id,"item":item}
    return results

third way doing the same as we do in the above:
Example:
 
from fastapi import FastAPI ,Body
from pydantic import BaseModel 
   
app=FastAPI()

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None


@app.put("/items/{item_id}")
async def update_item(
    item_id:int,item:Item=Body(...,example={
                "name":"Foo",
                "description":"a very price nice item",
                "price":16.25,
                "tax":1.67,

            })):
    results={"item id ": item_id,"item":item}
    return results

Example4: Not working
 
from fastapi import FastAPI ,Body
from pydantic import BaseModel 
   
app=FastAPI()

class Item(BaseModel):
    name:str
    description:str|None=None
    price:float
    tax:float|None=None
 
@app.put("/items/{item_id}")
async def update_item(
    item_id:int,
    item:Item=Body(
        ...,
        examples={

            "normal":{
                "Summary":"An normal Example",
                "description":"A normal example item works correctly",
                "value":{
                    "name":"Foo",
                    "description":"a very price nice item",
                    "price":16.25,
                    "tax":1.67,
                }
            },
            "converted":{
                "summary":"An Example with converted data",
                "description":"FastAPI can converts price string to actual number automatically",
                "value":{"name":"Bar","price":"16.25"},
            },
            "Invalid":{
                "Summary":"Invalid data is rejected with an error",
                "description":"hello you tubers",
                "value":{"name":"Baz","price":"sixteen point two five"},
            },
        }
                )):
    results={"item id ": item_id,"item":item}
    return results

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 11: Extra Data Types
=============================

Example of UUID:
----------------
 
from fastapi import FastAPI ,Body
from pydantic import BaseModel 
from uuid import UUID 
from datetime import datetime,time,timedelta

app=FastAPI()
 
  
@app.put("/items/{item_id}")
async def update_item(
    item_id:UUID,
    start_date:datetime | None=Body(None),
    end_date:datetime|None=Body(None),
    repeat_at:time | None=Body(None),
    process_after:timedelta | None=Body(None)

):
    start_process=start_date + process_after
    duration=end_date -start_process
    return {
        "item id ": item_id,
        "start date" : start_date,
        "end date ":end_date,
        "repeat_at":repeat_at,
        "process_after":process_after,
        "start_process":start_process,
        "duration":duration
        }
        
"""
    (fast_env) C:\Users\preet\OneDrive\Desktop\FAST_API>python
    Python 3.11.6 (tags/v3.11.6:8b6ee5b, Oct  2 2023, 14:57:12) [MSC v.1935 64 bit (AMD64)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    >>> from uuid import uuid4
    >>> uuid4()
    UUID('9e5318e4-9e10-4e57-b8b3-396883fffca4')
    >>>
"""
request Body:
curl -X 'PUT' \
  'http://127.0.0.1:8000/items/9e5318e4-9e10-4e57-b8b3-396883fffca4' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "start_date": "2023-12-11T14:24:55.402Z",
  "end_date": "2023-12-11T14:24:55.402Z",
  "repeat_at": "14:24:55.402Z",
  "process_after": "P3D"
}'
response:
{
  "item id ": "9e5318e4-9e10-4e57-b8b3-396883fffca4",
  "start date": "2023-12-11T14:24:55.402000+00:00",
  "end date ": "2023-12-11T14:24:55.402000+00:00",
  "repeat_at": "14:24:55.402000+00:00",
  "process_after": 259200,
  "start_process": "2023-12-14T14:24:55.402000+00:00",
  "duration": -259200
}





++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 12: Cookie and Header Parameters
=========================================
from fastapi import FastAPI, Body,Path,Cookie,Header


app = FastAPI()

"""
got to swagger and inspects--->network--items--<Request Body Header

"""
@app.get("/items")
async def read_items(
        cookies_id      :str | None = Cookie(None),
        accept_encoding :str |None  = Header(None),
        sec_ch_ua       :str |None  = Header(None),
        user_agent      :str |None  = Header(None),
        x_token         :list[str] |None  = Header(None),


):
    return {
            "cookies_id"        : cookies_id,
            "accept_encoding"   : accept_encoding,
            "sec_ch_ua"         : sec_ch_ua,
            "user_agent"        : user_agent,
            "x_token"           : x_token,

            }



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 13: Response Model
===========================

in the swagger we can see, schema is a string if we not set response model.

from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr

app = FastAPI()

class Item(BaseModel):
    name        :str
    description :str    |None=None
    price       :float
    tax         :float  |None=None
    tags        :list[str]=[]

@app.post("/items/",response_model=Item)
async def create_item(item:Item):
    return item


Example2:
========
class UserIn(BaseModel):
    username : str
    password : str
    email    : EmailStr
    full_name :str | None =None

@app.post("/user/",response_model=UserIn)
async def create_user(user: UserIn):
    return user

actually password id visible in the reponse body, that is not at all good so what we can do

Example3:
=========
from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr

app = FastAPI()


class UserBase(BaseModel):
    username : str
    email: EmailStr
    full_name: str | None = None

class UserIn(UserBase):
    password : str

class UserOut(UserBase):
    pass


@app.post("/user/",response_model=UserOut)
async def create_user(user: UserIn):
    return user

Now we can see the difference in request body and response body or schema.
request body

{
  "username": "string",
  "email": "user@example.com",
  "full_name": "string",
  "password": "string"
}

response body
{
  "username": "string",
  "email": "user@example.com",
  "full_name": "string"
}

 

Example:-->how we can exlude and include elements in response_model:
=======
from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal
app = FastAPI()


class Item(BaseModel):
    name        :str
    description :str    |None=None
    price       :float
    tax         :float  =10.5
    tags        :list[str]=[]

items={
    "foo":{"name":"Foo","price":50.2},
    "bar":{"name":"Bar","description":"The barattender","price":62,"tax":20.3},
    "baz":{"name":"Baz","decription":None,"price":50.2,"tax":10.5,"tags":[]}
}
'''
response_model_exclude_unset=True: if we include this will not get any default values which we set
above in items dictionary.


'''
@app.get("/items/{item_id}",response_model=Item,response_model_exclude_unset=True)
async def read_item(item_id:Literal["foo","bar","baz"]):
    return items[item_id]

 
@app.get("/items/{item_id}/name",response_model=Item,response_model_include={"name","description"})
async def read_item_name(item_id:Literal["foo","bar","baz"]):
    return items[item_id]

 
  
@app.get("/items/{item_id}/public",response_model=Item,response_model_exclude={"tax"})
async def read_item_public(item_id:Literal["foo","bar","baz"]):
    return items[item_id]


Example:
=======
in the given example we are includng some items and excluding the password from the response
model.

from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal
app = FastAPI()


class UserBase(BaseModel):
    username : str
    email: EmailStr
    password : str| None = None
    full_name: str | None = None

user={
    "foo":{"username":"Foo","email":"foo@gmail.com"},
    "bar":{"username":"Bar","email":"foo@gmail.com","password":"bar1234","full_name":'Attender'},
    "baz":{"username":"Baz","email":"foo@gmail.com","password":"baz123"}
}
@app.get("/user/{user_id}",response_model=UserBase)
async def get(user_id:Literal["foo","bar","baz"]):
    return user[user_id]
 
@app.get("/user/{user_id}/name",response_model=UserBase,response_model_include={"username","email"})
async def get_name(user_id:Literal["foo","bar","baz"]):
    return user[user_id]

@app.get("/user/{user_id}/public",response_model=UserBase,response_model_exclude={"password"})
async def get_name_public(user_id:Literal["foo","bar","baz"]):
    return user[user_id]


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 14: Extra Models
=========================
Exmaple:
=======
from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal
app = FastAPI()


class UserIn(BaseModel):
    username : str 
    password : str 
    email : EmailStr
    full_name: str | None =None

class UserOut(BaseModel):
    username : str 
    email : EmailStr
    full_name: str | None =None

class UserInDB(BaseModel):
    username : str 
    hashed_password : str 
    email : EmailStr
    full_name: str | None =None

def fake_password_hasher(raw_password: str):
    return f"supersecret{raw_password}"

def fake_save_user(user_in:UserIn):
    hashed_password=fake_password_hasher(user_in.password)
    user_in_db=UserInDB(**user_in.dict(),hashed_password=hashed_password)/
    #if we provide the extrac params also it will take only declared ones, remaining will gets skipped.
    # print(UserInDB(
    #     username="hello",
    #     email="email@gmail.com",
    #     password="password",
    #     hello="world",
    #     foo="bar"



    # ))
    print("User Saved..",user_in_db)
    return user_in_db 

@app.post("/user/",response_model=UserOut)
async def create_user(user_in:UserIn):
    user_saved=fake_save_user(user_in) #saving the like in a database
    return user_saved

Now lets remove some of the duplication using AsbractBase class.
================================================================
Exmaple:
=======
rom fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal
app = FastAPI()

class UserBase(BaseModel):
    username : str 
    email : EmailStr
    full_name: str | None =None

class UserIn(UserBase):
    password : str 
  

class UserOut(UserBase):
    pass

class UserInDB(UserBase):
    hashed_password : str 
 

def fake_password_hasher(raw_password: str):
    return f"supersecret{raw_password}"

def fake_save_user(user_in:UserIn):
    hashed_password=fake_password_hasher(user_in.password)
    user_in_db=UserInDB(**user_in.dict(),hashed_password=hashed_password)/
    print("User Saved..",user_in_db)
    return user_in_db 

@app.post("/user/",response_model=UserOut)
async def create_user(user_in:UserIn):
    user_saved=fake_save_user(user_in) #saving the like in a database
    return user_saved

Now lets see the Union types:
=============================
Example: Notw working getting bugs
=======
from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal,Union
app = FastAPI()


class BaseItem(BaseModel):
    description: str
    type: str

class CarItem(BaseItem):
    type="car"
   

class PlanItem(BaseItem):
    type="plane"
    size: int
   

items={
    "item1":{"description":"all my friends drive a low rider","type":"car"},
    "item2":{"description":"Music is my plane ","type":"plane","size":5}
}

@app.get("/items/{item_id}",response_model=Union[PlanItem,CarItem])
async def read_items(item_id:Literal["Item1","item2"]):
    return items[item_id]


in the above example instead of using Union 
like 
    @app.get("/items/{item_id}",response_model=Union[PlanItem,CarItem])
we can use:
    @app.get("/items/{item_id}",response_model=PlanItem | CarItem)

or:
@app.get("/items/{item_id}")
async def read_items(item_id:Literal["Item1","item2"]-> PlanItem | CarItem):
    return items[item_id]


Example:
========
from fastapi import FastAPI, Body,Path,Cookie,Header
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal,Union
app = FastAPI()



class ListItem(BaseModel):
    name: str 
    description:str 

list_items=[
    {"name":"Foo","description":"there is my hero"},
    {"name":"REd","description":"Its my plane"}
]

@app.get("/list_item/",response_model=list[ListItem])
async def read_items():
    return items

@app.get("/arbitrary",response_model=dict[str,float])
async def get_arbitrary():
    return {"foo":1,"bar":"2"}

#response_model=dict[str,float]: this defined the key should be string and value should be float if not then it will typecast the value not the key

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 15: Response Status Codes
==================================
Exmaple1:
=======
from fastapi import FastAPI, Body,Path,Cookie,Header,status
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal,Union

app = FastAPI()

#if we not include the status code by default its show 200 as status code.
@app.post("/items/",status_code=201)
async def create_item(name:str):
    return {"name":name}

@app.delete("/items/{pk}",status_code=204) #204 is No Content status code.
async def delete_item(pk:str):
    print("pk :",pk)
    return pk

@app.get("/items/",status_code=401)
async def read_item_redirect():
    return {"hello":"world"}

 Example2:
 ========
 from fastapi import FastAPI, Body,Path,Cookie,Header,status
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal,Union

app = FastAPI()

#if we not include the status code by default its show 200 as status code.
@app.post("/items/",status_code=status.HTTP_201_CREATED)
async def create_item(name:str):
    return {"name":name}

@app.delete("/items/{pk}",status_code=status.HTTP_204_NO_CONTENT) #204 is No Content status code.
async def delete_item(pk:str):
    print("pk :",pk)
    return pk

@app.get("/items/",status_code=status.HTTP_302_FOUND)
async def read_item_redirect():
    return {"hello":"world"}



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 16: Form Fields
========================
exmaple: handling the form Feild data with Form:
----------------------------------------------
from fastapi import FastAPI, Body,Path,Cookie,Header,status,Form
from pydantic import BaseModel,Field,HttpUrl,EmailStr
from typing import Literal,Union

app = FastAPI()

class User(BaseModel):
    username: str
    password: str

@app.post("/login_1/")
async def login_json(user: User):
    return user

#the below one also send the data in the form of json only
@app.post("/login_2/")
async def login_json_body(user: str=Body(...),password:str=Body(...)):
    return {"user":user,"password":password}

@app.post("/login_3/")
async def login_formfield(user: str=Form(...),password:str=Form(...)):
    return {"user":user,"password":password}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 17: Request Files [few routes not working]
==========================
Example:1
=========
from fastapi import FastAPI, File, UploadFile

app = FastAPI()

@app.post("/files/")
async def create_file(file: bytes=File(...)): #this will ask to updaliad the file and read the content and send as reponse back
    return {"file":file,"file length":len(file)}

@app.post("/uploadfile/")
async def create_upload_file(file:UploadFile): #generally we use way
    return {"file name":file.filename}

@app.post("/uploadfile_2/")
async def create_upload_file_2(file:UploadFile):
    contents= await file.read()
    return {"file name":file.filename


 Example:2 Error:
 ================
 from fastapi import FastAPI, File, UploadFile
from starlette.responses import HTMLResponse

app = FastAPI()

#sending the single file
# @app.post("/file/")
# async def create_file(file: bytes| None=File(None)):
#     if not file:
#         return {"message": "No file sent"}
#     return {"file":file,"file length":len(file)}

#sending the list of  files:
@app.post("/files/")
async def create_files(files: [bytes]=File(None,description="No file sent as bytes")):
    if not files:
        return {"message": "No file sent"}
    return {"files":files,"file length":[len(file) for file in files]}


#sending the single file
# @app.post("/uploadfile/")
# async def create_upload_file(file:UploadFile | None=File(None,description="A file read as upload file ")):
#     if not file:
#         return {"message": "No upload file  sent"}
#     return {"file name":file.filename}

#sending the list of  files:
@app.post("/uploadfiles/")
async def create_upload_files(files :[UploadFile] =File(None,description="A file read as upload file ")):
    if not files:
        return {"message": "No upload file  sent"}
    return {"file name":[file.filename for file in files]}


@app.get("/")
async def main():
    content="""
    <body>
        <form action="/files/ enctype="multipart/form-data method=post>
        <input type="file" name="files" multiple>
        <input type="submit" value="">
        </form>

        <form action="/uplaodfiles/ enctype="multipart/form-data method=post>
        <input type="file" name="files" multiple>
        <input type="submit" value="">
        </form>

    """
    return HTMLResponse(content=content)




++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 18: Request Forms and Files
===================================
The Body sends the data in the json form but while posting data if we have single form data the entire post
request converts into form data you can check in the inspect--payload

Example:
=======

from fastapi import FastAPI, File, UploadFile, Form, Body
from starlette.responses import HTMLResponse

app = FastAPI()

@app.post("/files")
async def create_file(file: bytes=File(...),fileb: UploadFile=File(...),token:str=Form(...),hello:str=Body(...)):
    return {
        "file_size": len(file),
        "token": token,
        "fileb_content_type": fileb.content_type,
        "hello":hello
    }


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 19: Handling Errors
=============================
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from fastapi.exceptions import RequestValidationError
from starlette.requests import Request
from starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException
app = FastAPI()

items={"foo":"the foo wreshlters"}

@app.get("/items/{item_id}")
async def read_item(item_id: str):
    if item_id not in items:
        #if we not raise the exception like below then without this server response internal serverver error.
        raise HTTPException(status_code=404,detail="Item not found",headers={"X-Error":"Item not found"})
    return {"item":items[item_id]}

#we dont need to handle the exception manully like above
#we can extent the BaseException and create custom exception

class UnicornException(Exception):
    def __init__(self,name:str):
        self.name = name

@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request,exc: UnicornException):
    return JSONResponse(status_code=408,content={'message':f"opps! {exc.name} did something. There is rainbow"})

@app.get("/unicorns/{names}")
async def read_unicorns(names:str):
    if names == "hello":
        raise UnicornException(name=names)
    return {"Unicorn_name":names}

#example2
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request,exc):
    return PlainTextResponse(content=str(exc),status_code=400)

@app.get("/validation_items/{item_id}")
async def read_validation_item(item_id: int):
    if item_id ==3:
        raise HTTPException(status_code=408, detail="Nope I dont like 3")
    return {"item":items[item_id]}

Example3:
========
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from fastapi.encoders import jsonable_encoder
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel
from starlette import status
from starlette.requests import Request
from starlette.responses import HTMLResponse, JSONResponse, PlainTextResponse
from starlette.exceptions import HTTPException as StarletteHTTPException
app = FastAPI()

 #example3: Overriding the Exception Handler
@app.exception_handler(StarletteHTTPException)
async def http_exception_handler(request,exc):
    return PlainTextResponse(content=str(exc.details),status_code=exec.status_code)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request,exc: RequestValidationError):
    return JSONResponse(status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,content=jsonable_encoder({"detail":exc.errors,"body":exc.body}))

class Item(BaseModel):
    title: str
    size: int

@app.post("/items/")
async def create_item(item:Item):
    return {"item":item}


Example:
=======
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from fastapi.exception_handlers import http_exception_handler,request_validation_exception_handler
app = FastAPI()

@app.exception_handler(StarletteHTTPException)
async def custome_http_exception_handler(request,exc):
    print(f"OMG An Http Error ! : {repr(exc)}")
    return await http_exception_handler(request,exc)
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request,exc):
    print(f"OMG client sends invalid data {exc}")
    return await request_validation_exception_handler(request,exc)

@app.get("/blah_items/{item_id}")
async def read_item(item_id: int):
    if item_id == 3:
        raise HTTPException(status_code=413,detail="Nope I dont like 3 ")
    return {"item_id": item_id}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 20: Path Operation Configuration
=========================================
To clasify or segregate the routes in systamatic form, we can use tags["name_tag"], in the decorator.
Example1:
========
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from pydantic import BaseModel
from starlette import status

app = FastAPI()

class Item(BaseModel):
    name:str
    description: str
    price:float
    tax:float | None=None
    tag: set[str]=set()

@app.post("/items/",response_model=Item,status_code=status.HTTP_201_CREATED,tags=["items"])
async def create_item(item:Item):
    return item

@app.get("/items/",tags=["items"])
async def read_items():
    return [{"name":"foo","price":42}]

@app.get("/users/",tags=["users"])
async def get_users():
    return [{'username':"FooBay"}]


Example2:
========
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from pydantic import BaseModel
from sqlalchemy import Enum
from starlette import status

app = FastAPI()

class Item(BaseModel):
    name:str
    description: str
    price:float
    tax:float | None=None
    tag: set[str]=set()

class Tags(Enum):
    items="items"
    users="users"

@app.post(
    "/items/"
    ,response_model=Item,
    status_code=status.HTTP_201_CREATED,
    tags=[Tags.items],
    summary="Create an item type item",
    description="Create an item with all the information : name : description : price : tax : and unquie set of tags",

)
async def create_item(item:Item):
    return item

@app.get("/items/",tags=[Tags.items])
async def read_items():
    return [{"name":"foo","price":42}]

@app.get("/users/",tags=[Tags.users])
async def get_users():
    return [{'username':"FooBay"}]


Example2:
=========
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from pydantic import BaseModel
from sqlalchemy import Enum
from starlette import status

app = FastAPI()

class Item(BaseModel):
    name:str
    description: str
    price:float
    tax:float | None=None
    tag: set[str]=set()

class Tags(Enum):
    items="items"
    users="users"

@app.post(
    "/items/"
    ,response_model=Item,
    status_code=status.HTTP_201_CREATED,
    tags=[Tags.items],
    response_description="The create Item"
)
async def create_item(item:Item):
    """
    Create an item with all the information
    -   **name**: each item must have a name
    -   **description**: a long description of the item
    -   **price**:required
    -   **tax**: if the item doesnt have tas , you can omit it
    -   **tag**: a set of unique tag strings for this item.

    """
    return item

@app.get("/items/",tags=[Tags.items])
async def read_items():
    return [{"name":"foo","price":42}]

@app.get("/users/",tags=[Tags.users])
async def get_users():
    return [{'username':"FooBay"}]

@app.get("/element/",tags=[Tags.items],deprecated=True)
async def read_element():
    return [{"item id ":"Foo"}]

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 21: JSON Compatible Encoder and Body Updates
====================================================
Usally when we saving data in the database from the post and put request some of the datatype is not
compitable with database, so we need to type cast accordingly with database, so going manaully changing each
arrtibute we can use Encoders.

Example1:
=======
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel


app = FastAPI()

fake_db={}

class Item(BaseModel):
    title:str
    timestamp:datetime
    description:str | None=None

@app.put("/items_1/{id}")
async def update_item(id:str,item:Item):
    fake_db[id]=item #{'100': Item(title='string', timestamp=datetime.datetime(2023, 12, 31, 17, 40, 34, 176000, tzinfo=TzInfo(UTC)), description='string')}
    #we can observe the datatime is an python object so we need to canvert to database type

    print(fake_db)
    return "success"


@app.put("/item_2/{id}")
async def update_item_json(id: str, item: Item):
    json_compatible_item_data=jsonable_encoder(item)
    fake_db[id] = json_compatible_item_data #{'hello': {'title': 'string', 'timestamp': '2023-12-31T17:44:32.957000Z', 'description': 'string'}}
    #now every attribute is converted it into string.
    print(fake_db)
    return "success"


Example:2
========
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel


app = FastAPI()

class Item(BaseModel):
    name:str | None=None
    description:str | None=None
    price:float | None=None
    tax:float=10.5
    tag:list[str]=[]

items={
    "foo":{"name":"Foo","price":50.2},
    "bar":{"name":"Bar","description":"The barattender","price":62,"tax":20.2},
    "baz":{"name":"Baz","description":None,"price":50.2,"tax":10.5,"tags":[]}

}

@app.get("/items/{item_id}",response_model=Item)
async def read_item(item_id:str):
    return items.get(item_id)

@app.put("/items/{item_id}",response_model=Item)
async def update_item(item_id:str,item:Item):
    update_item_encoded=jsonable_encoder(item)
    items[item_id] = update_item_encoded
    return update_item_encoded

@app.patch("/items/{item_id}",response_model=Item)
async def patch_item(item_id:str,item:Item):
    stored_item_data=items.get(item_id)
    if stored_item_data is not None:
        stored_item_model=Item(**stored_item_data)
    else:
        stored_item_model=Item()
    update_data=item.dict(exclude_unset=True)
    update_item=stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(update_item)
    print(items)
    return update_item

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:  22: Dependencies - Intro
=================================

problem: is redundant code.
---------------------------
app = FastAPI()
@app.get("/items/")
async def read_items(q: str | None = None, skip: int = 0, limit: int =100):
    return {"q": q, "skip": skip, "limit":limit}

@app.get("/users/")
async def read_users(q: str | None = None, skip: int = 0, limit: int =100):
    return {"q": q, "skip": skip, "limit":limit}

solution: dependency function.
-----------------------------
Example:
from datetime import datetime
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel


app = FastAPI()

async def common_parameters(q: str | None = None, skip: int = 0, limit: int =100):
    return {"q": q, "skip": skip, "limit":limit}

@app.get("/items/")
async def read_items(common: dict = Depends(common_parameters)):
    return common

@app.get("/users/")
async def read_users(common: dict = Depends(common_parameters)):
    return common

 Example3:
 ========
 app = FastAPI()

#nested Dependecy function:
async def hello():
    return {"message": "Hello World"}

async def common_parameters(q: str | None = None, skip: int = 0, limit: int =100,blah: str=Depends(hello)):
    return {"q": q, "skip": skip, "limit":limit,"hello":blah}

@app.get("/items/")
async def read_items(common: dict = Depends(common_parameters)):
    return common

@app.get("/users/")
async def read_users(common: dict = Depends(common_parameters)):
    return common



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 23: Classes as Dependencies
====================================

from datetime import datetime
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app=FastAPI()

# class Cat:
#     def __init__(self, name: str):
#         self.name = name
#
#
# fluffy = Cat(name="Mr Fluffy")

fake_items_db=[{"item_name":"Foo"},{"item_name":"Bar"},{"item_name":"Baz"}]

class CommonQueryParams:
    def __init__(self,q: str | None = None, skip: int = 0, limit: int =100):
        self.q=q
        self.skip=skip
        self.limit=limit

@app.get("/items/") #its something like a pagination
async def read_items(commons:CommonQueryParams = Depends(CommonQueryParams)):
    response={}
    if commons.q:
        response.update({"q":commons.q})
    items=fake_items_db[commons.skip:commons.skip+commons.limit]
    response.update({"items":items})
    return response

  or we can go as:
  ----------------
@app.get("/items/") #its something like a pagination
async def read_items(commons:CommonQueryParams = Depends()):
    response={}
    if commons.q:
        response.update({"q":commons.q})
    items=fake_items_db[commons.skip:commons.skip+commons.limit]
    response.update({"items":items})
    return response

   or:
   ===>

   @app.get("/items/") #its something like a pagination
async def read_items(commons= Depends(CommonQueryParams)):
    response={}
    if commons.q:
        response.update({"q":commons.q})
    items=fake_items_db[commons.skip:commons.skip+commons.limit]
    response.update({"items":items})
    return response


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 24: Sub-Dependencies
==============================
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends

app=FastAPI()

def query_extractor(q: str | None = None):
    return q

def query_or_body_extractor(q:str=Depends(query_extractor),last_query:str | None=Body(None)):
    if not q:
        return last_query
    return q
@app.post("/items")
async def try_query(query_or_body: str = Depends(query_or_body_extractor)):
    return {"q_or_body":query_or_body}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session:25: Dependencies in path operation decorators, global dependencies
==========================================================================
Dependencies in path operation decorators
-----------------------------------------
Example:
=======
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends, Header

app=FastAPI()

async def verify_token(x_token: str=Header(...)):
    if x_token !="fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key :str = Header()):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

@app.get("/items/", dependencies=[Depends(verify_token), Depends(verify_key)])
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]

Example2:global dependencies
============================
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends, Header

async def verify_token(x_token: str=Header(...)):
    if x_token !="fake-super-secret-token":
        raise HTTPException(status_code=400, detail="X-Token header invalid")

async def verify_key(x_key :str = Header()):
    if x_key != "fake-super-secret-key":
        raise HTTPException(status_code=400, detail="X-Key header invalid")
    return x_key

app=FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)])
@app.get("/items/", )
async def read_items():
    return [{"item": "Foo"}, {"item": "Bar"}]


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 26: Security
======================
from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends, Header
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from pydantic import BaseModel
from starlette import status


app=FastAPI()

oauth_scheme=OAuth2PasswordBearer(tokenUrl="token")

fake_user_db={
    "ravi":dict(
        username="ravi",
        full_name="Ravi sharma",
        email="ravi@gmail.com",
        hassed_password="ravi1234",
        disable=False),
    "tom":dict(
        username="tom",
        full_name="tom parker",
        email="tom@gmail.com",
        hassed_password="fakehashedsecret",
        disable=True)
}

def fake_hashed_password(password: str):
    print(f"fakehashed{password}")
    return f"fakehashed{password}"

class User(BaseModel):
    username: str
    email:str|None=None
    full_name:str|None=None
    disabled:bool|None=None

class UserInDB(User):
    hashed_password:str

def get_user(db,username:str):
    if username in db:
        user_dict=db[username]
        return UserInDB(**user_dict)

def fake_decode_token(token):
    return get_user(fake_user_db,token)

async def get_curren_user(token: str= Depends(oauth_scheme)):
    user=fake_decode_token(token)
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail = "Invalid Authentication Credentails",headers={"WWW-Authenticate":"Bearer"})
    return user

async def get_current_active_user(curent_user: User = Depends(get_curren_user)):
    if curent_user.disabled:
        raise HTTPException(status_code=400,detail="User disabled")
    return curent_user

@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm =Depends()):
    user_dict=fake_user_db.get(form_data.username)
    print("user :", user_dict)
    if not user_dict:
        raise HTTPException(400,detail="Invalid username or password")
    user=UserInDB(**user_dict)

    hashed_password=fake_hashed_password(form_data.password)
    if not hashed_password == user.hashed_password:
        raise HTTPException(400, detail="Invalid username or password")
    return {"access token":user.username,"token_type":"bearer"}


@app.get("/user/me")
async def get_me(current_user:User = Depends(get_current_active_user)):
    return current_user
@app.get("/items/")
async def read_items(token:str=Depends(oauth_scheme)):
    return {"items":token}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 27: Security with JWT
==============================
JWT is a stateless means of authentication.
its compraise the three parts.
        Alogorith
        data
        signature.

go to jwt.io and check.

first install some packages.

python-jose[cryptography]
passlib[bcrypt]

in shell scripting:
    >>> from passlib.context import CryptContext
    >>> pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    >>> pwd_context.hash('password1234')
        '$2b$12$yafNlq1pFErm7/1cd9fYgu.nRlmJNHM59PFy7A9Rp4mgRj1TiIDNq'

 the generated access token you can paste in the hasdded_password in fake_user_db.
 as shown below

 note:
    always stored the hashed password in the DB.
    dont put the sensitive data in the payload of access token.

 in the swagger give user name as "johndoe" and password as "password1234",
 you will get the access token and
 then check in the JWT.io portal by pasting its showing the invalid signature then paste the screte key
 the access key will ba a valid signature.

Example:
import datetime
from datetime import timedelta

from fastapi import FastAPI, File, UploadFile, Form, Body, HTTPException, Depends, Header
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from passlib.context import CryptContext
from jose import jwt,JWTError
from pydantic import BaseModel
from starlette import status

app=FastAPI()

SECRET_KEY = 'thequickbrownfoxjumpsoverthelazydog'
ALGORITHM = 'HS256'
ACCESS_TOKEN_EXPIRE_MINUTES =30

fake_user_db=dict(
    johndoe=dict(
        username="johndoe",
        full_name="John Doe",
        hashed_password="$2b$12$0b96TaRJtNk5EeU647VYweWguTOOb6B3XwUkpY0XEnHuZf59O9aTi",
        disabled=False


    )
)

class Token(BaseModel):
    access_token:str
    token_type:str

class TokenData(BaseModel):
    username:str | None=None

class User(BaseModel):
    username:str
    email:str | None=None
    full_name:str | None=None
    disabled:bool=False
class UserInDB(User):
    hashed_password:str

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password,hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def get_user(db,username:str):
    if username in db:
        user_dict=db[username]
        return UserInDB(**user_dict)

def authenticate_user(fake_db,username:str,password:str):
    user=get_user(fake_db,username)
    if not user:
        return False
    if not verify_password(password, user.hashed_password):
        return False
    return user

def create_access_token(data: dict, expires_delta:timedelta | None =None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.datetime.now() + expires_delta
    else:
        expire = datetime.datetime.now() + timedelta(minutes=15)
    to_encode.update({"exp":expire})
    encoded_jwt = jwt.encode(to_encode,SECRET_KEY,algorithm=ALGORITHM)
    return encoded_jwt
@app.post("/token",response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm =Depends()):
    user=authenticate_user(fake_user_db,form_data.username,form_data.password)
    if not user:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail="Incorrect username or password",headers={"WWW-Authenticate": "Bearer"})

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token=create_access_token(
        data={"sub":user.username},expires_delta=access_token_expires
    )
    return {"access_token":access_token,"token_type":"bearer"}



async def get_current_user(token: str = Depends(oauth2_scheme)):
    credential_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,detail="Could not validate credentials",headers={"WWW-Authenticate": "Bearer"})
    try:
        payload = jwt.decode(token,SECRET_KEY,algorithms=ALGORITHM)
        username:str=payload.get("sub")
        if username is None:
            raise credential_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credential_exception
    user=get_user(fake_user_db,username=token_data.username)
    if user is None:
        raise credential_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if current_user.disabled:
        raise HTTPException(status_code=400,detail="Inactive user")
    return current_user

@app.get("/user/me",response_model=User)
async def get_me(current_user: User = Depends(get_current_active_user)):
    return current_user

@app.get("/user/me/items")
async def read_own_items(current_user: User = Depends(get_current_active_user)):
    return [{"item_id":"foo","owner":current_user.username}]


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 28: Middleware and CORS
=================================

Middleware: with it we can add the functionality to each route.
CORS or "Cross-Origin Resource Sharing" refers to the situations when a frontend running in a browser has JavaScript code
that communicates with a backend, and the backend is in a different "origin" than the frontend

basic middlerware example:
========================
import datetime
import time
from datetime import timedelta

from fastapi import FastAPI,Request
from starlette.middleware.base import BaseHTTPMiddleware


app = FastAPI()


class MyMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        response.headers['X-Process-Time'] = str(process_time)
        return response



origins = ["http://localhost:8000","http://localhost:3000"]
app.add_middleware(MyMiddleware)
app.add_middleware(CORSMiddleware,allow_origins=origins)


@app.get("/blah")
async def hello_world():
    return {"hello": "world"}

used to create front-end apps:
    https://kit.svelte.dev/

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 29: SQL Relational Databases
=====================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 
=================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 
=================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 
=================================
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Session: 
=================================








    






 

 





    






 

 




    






 

 













 

 
 












