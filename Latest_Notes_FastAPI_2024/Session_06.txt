___________________________________________________________________________________________________________________________________________________________
Concept:
	1.Extra Data Types
	2.Cookie Parameters and Headers
___________________________________________________________________________________________________________________________________________________________



Extra Data Types
----------------
	1. UUID:
		A standard "Universally Unique Identifier", common as an ID in many databases and systems.
		In requests and responses will be represented as a str.

	2.datetime.datetime:
		A Python datetime.datetime.
		In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.

	3.datetime.date:
		Python datetime.date.
		In requests and responses will be represented as a str in ISO 8601 format, like: 2008-09-15.

	4.datetime.time:
		A Python datetime.time.
		In requests and responses will be represented as a str in ISO 8601 format, like: 14:23:55.003.

	5.datetime.timedelta:
		A Python datetime.timedelta.
		In requests and responses will be represented as a float of total seconds.
		Pydantic also allows representing it as a "ISO 8601 time diff encoding", see the docs for more info.
	6.frozenset:
		In requests and responses, treated the same as a set:
		In requests, a list will be read, eliminating duplicates and converting it to a set.
		In responses, the set will be converted to a list.
		The generated schema will specify that the set values are unique (using JSON Schema's uniqueItems).
	7.bytes:
		Standard Python bytes.
		In requests and responses will be treated as str.
		The generated schema will specify that it's a str with binary "format".
	8.Decimal:
		Standard Python Decimal.
		In requests and responses, handled the same as a float.

You can check all the valid pydantic data types here: Pydantic data types
Example1:
--------
from datetime import datetime, time, timedelta
from uuid import UUID

from fastapi import FastAPI, Body

app = FastAPI()

@app.put("/employee/{empid}")
async def update_employee(
        empid: UUID,
        start_date: datetime | None = Body(None),
        end_date: datetime | None = Body(None),
        repeat_at : time | None = Body(None),
        process_after : timedelta | None = Body(None)

):
    start_process=start_date + process_after
    duration=end_date - start_process

    return {
        "item id ": empid,
        "start date": start_date,
        "end date ": end_date,
        "repeat_at": repeat_at,
        "process_after": process_after,
        "start_process": start_process,
        "duration": duration
    }

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Cookie Parameters and Headers
=============================
	You can define Cookie parameters the same way you define Query and Path parameters like
		from fastapi import FastAPI, Body,Path,Cookie,Header
Cookie is a "sister" class of Path and Query. It also inherits from the same common Param class.

Example-1
from fastapi import FastAPI, Body,Path,Cookie,Header


app = FastAPI()

"""
got to swagger and inspects--->network--items--<Request Body Header

"""
@app.get("/items")
async def read_items(
        cookies_id      :str | None = Cookie(None),
        accept_encoding :str |None  = Header(None),
        sec_ch_ua       :str |None  = Header(None),
        user_agent      :str |None  = Header(None),
        x_token         :list[str] |None  = Header(None),


):
    return {
            "cookies_id"        : cookies_id,
            "accept_encoding"   : accept_encoding,
            "sec_ch_ua"         : sec_ch_ua,
            "user_agent"        : user_agent,
            "x_token"           : x_token,

            }

