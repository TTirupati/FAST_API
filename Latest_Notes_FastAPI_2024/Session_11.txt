Path Operation Configuration:
----------------------------
		Response Status Code
		Tags
		Tags with Enums
		Summary and description
		Description from docstring
		Response description
		Deprecate a path operation

1. Response Status Code:
		it is very hard to remember the status code, instead of it we can use status_code in path operation.

Example:-1
----------
from fastapi import FastAPI
from pydantic import BaseModel
from starlette import status

app = FastAPI()


class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

@app.post("/employees",status_code=status.HTTP_201_CREATED)
async def create_employee(employee:Employee):
    return employee

2.Tags:
--------
	To clasify or segregate the routes in systamatic form, we can use tags["name_tag"], in the decorator.
Example
-------
from fastapi import FastAPI
from pydantic import BaseModel
from starlette import status

app = FastAPI()


class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

class Project(BaseModel):
    project_id : int
    project_name : str


@app.post("/employees",status_code=status.HTTP_201_CREATED,tags=["Employee Table"])
async def create_employee(employee:Employee):
    return employee

@app.post("/projects",status_code=status.HTTP_201_CREATED,tags=["Project Table"])
async def create_project(project: Project):
    return project


Tags with Enums:
---------------
	If you have a big application, you might end up accumulating several tags, and you would want to make sure you always use the same tag for related path operations.
	In these cases, it could make sense to store the tags in an Enum.


Example:
from fastapi import FastAPI
from pydantic import BaseModel
from starlette import status
from enum import Enum

app = FastAPI()


class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

class Project(BaseModel):
    project_id : int
    project_name : str

class Tags(Enum):
    employee="Employee"
    project="Project"


@app.post("/employees",status_code=status.HTTP_201_CREATED,tags=[Tags.employee])
async def create_employee(employee:Employee):
    return employee

@app.post("/projects",status_code=status.HTTP_201_CREATED,tags=[Tags.project])
async def create_project(project: Project):
    return project


3.Summary and description:
-------------------------
Example:
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

@app.post("/employees",response_model=Employee,summary="please create an employee record",description="create an employee record with all details where sallary and designation are optional")
async def create_employee(employee:Employee):
    return employee


4.Description from docstring
--------------------------
	As descriptions tend to be long and cover multiple lines, you can declare the path operation description in the function docstring and FastAPI will read it from there


- : is used to represent the list or bullets
**attr**: it makes in bold character.

Exmaple:
-------
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

@app.post("/employees",response_model=Employee,summary="please create an employee record")
async def create_employee(employee:Employee):
    '''
        Create an Employee with all the information:

    - **empid**: each item must have a name
    - **ename**: a long description
    - **salary**: required
    - **designation**: a set of unique tag strings for this item
    '''
    return employee


5.Response description:
----------------------
	You can specify the response description with the parameter response_description

Example:
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

@app.post("/employees",response_model=Employee,summary="please create an employee record",response_description="please create an employee it is hello !!")
async def create_employee(employee:Employee):
     return employee


Deprecate a path operation:
---------------------------
	If you need to mark a path operation as deprecated, but without removing it, pass the parameter deprecated

Example:
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Employee(BaseModel):
    empid : int
    ename : str
    salary : float | None=None
    designation : str | None=None

@app.post("/employees",deprecated=True)
async def create_employee(employee:Employee):
     return employee

@app.put("/employees/{empid}")
async def update_employee(empid:int,employee:Employee):
    return {"message": "it is updated successfully"}


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
JSON Compatible Encoder
=======================
	Usally when we saving data in the database from the post and put request some of the datatype is not
	compitable with database, so we need to type cast accordingly with database, so going manaully changing each
	arrtibute we can use Encoders.

	There are some cases where you might need to convert a data type (like a Pydantic model) to something compatible with JSON (like a dict, list, etc)


Example-1:
---------
from datetime import datetime

from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()

employee_database={}

class Employee(BaseModel):
    empid : int
    name : str
    timestamp : datetime
    designation : str

#without Json encoders
@app.put("/employee/{empid}")
async def update_employee(empid: int, emp:Employee):
    employee_database[empid]=emp
    print(employee_database) #{10101: Employee(empid=0, name='string', timestamp=datetime.datetime(2024, 2, 1, 4, 46, 21, 320000, tzinfo=TzInfo(UTC)), designation='string')}
    #we can observe the datatime is an python object so we need to canvert to database type
    return employee_database

#with Json encoders
@app.put("/employee2/{empid}")
async def update_employee_json_endoder(empid: int, emp:Employee):
    employee_database[empid]=jsonable_encoder(emp)
    print(employee_database)

    return employee_database


























